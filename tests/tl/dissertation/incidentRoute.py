''' 
The purpose of this code is to prepare the random demand 
generated by the randomTrips.py provided by SUMO official github.

The input is the random.rou.xml from running the command:
    python randomTrips.py -n net.net.xml -r random.rou.xml 
    --fringe-factor=100000000 --period=0.5 -e 900

The output is the editted random.rou.xml with one incident randomly occurs during the middle 1/3 of the simulation period and an emergency vehicle will be dispatched to deal with this incident. The incident relates to only one vehicle at this moment. 

The incident vehicle will stopped in the middle of the network. To leave the room for vehicle rerouting analysis later, the potential incident edges are the ones on the selected edges that around the center of the junctions.

Once the incident happens, the vehicle will stopped in one lane of that edge and adjacent available lane will be occupied once the service vehicle arrives. 
Author: Tianxin Li
Date: July 23, 2021

'''
import numpy as np
import random
import xml.etree.ElementTree as ET
from src.networkdata import NetworkData


import os, sys, optparse

if 'SUMO_HOME' in os.environ:
    tools = os.path.join(os.environ['SUMO_HOME'], 'tools')
    sys.path.append(tools)
    print(tools)
else:
    sys.exit("please declare environment variable 'SUMO_HOME'")

from sumolib import checkBinary  # Checks for the binary in environ vars
import traci


class Incident():
    def __init__(self, net_file, route_file, simulation_steps, n_incident=1, n_emergency=1):
        self.net = net_file
        self.route = route_file
        self.steps = simulation_steps
        self.n_incident = n_incident
        self.hasIncident = 0
        self.hasEmergencyDispatched = False
        # network data object from networkdata
        self.nd = NetworkData(self.net)
        self.origins = self.nd.find_origin_edges()
        self.destinations = self.nd.find_destination_edges()
        self.incident_edges = self.nd.incidentEdges
        # incident duration could be 15, 20, 25, and 30 minutes
        self.incident_duration = random.choice(np.arange(900, 2100, 300))
        self.incident_orrurance_time = self.get_incident_occurance_time()
        # parse route file generated by randomTrips.py
        self.tree = ET.parse(self.route)
        self.incident_veh, self.potential_incident_edges = self.generate_incident_veh()
        self.incident_edge = self.set_incident_edge()

        self.incident_lane, self.incident_lane_index = self.get_incident_lane()

        self.incident_location = self.get_incident_location()
        self.incident_cmd = '<stop duration="{}" endPos="{}" lane="{}" parking="false" />'.format(self.incident_duration, self.incident_location, self.incident_lane)

        # emergency vehicle parameters
        self.emergency_vehicle_length = 7.5 * n_emergency
    
    def get_incident_occurance_time(self):
        """ Get the incident occurance time in string format. """
    
        incident_occur_interval = self.steps/6

        incident_time = np.round(random.choice(np.arange(2*incident_occur_interval, 3 * incident_occur_interval, 1)), 2)

        return "{:.2f}".format(incident_time)


    # find incident element based on the incident time
    def get_incident_vehicle(self):
        vehs = self.tree.findall("vehicle")
        for x in vehs:
            if x.attrib["depart"] == self.incident_orrurance_time:
                return x

    # get the incident vehicle edges
    def get_veh_edges(self, veh):

        # get the edges from the veh element in string format
        veh_edges = veh.findall('route')[0].attrib["edges"]
        # split string into list
        veh_edges = veh_edges.split()
        return veh_edges

    def get_potential_incident_edges(self, veh_edges):
        edges = []
        for e in veh_edges:
            if e in self.incident_edges:
                edges.append(e)
        return edges

    def generate_incident_veh(self):
        es = []
        veh = None
        while len(es) < 1:
            self.incident_orrurance_time = self.get_incident_occurance_time()
            veh = self.get_incident_vehicle()
            route = self.get_veh_edges(veh)
            p_es = self.get_potential_incident_edges(route)
            es = p_es
        return veh, es

    def get_incident_veh_id(self):
        return self.incident_veh.attrib["id"]

    def get_incident_veh_depart(self):
        return self.incident_veh.attrib["depart"]

    def get_incident_occur_edges(self):
        return self.potential_incident_edges

    def set_incident_edge(self):
        return random.choice(self.potential_incident_edges)

    def get_incident_lane(self):
        e = self.incident_edge
        n_lanes = self.nd.edge_data[e]["nlanes"]
        lane_index = random.randrange(n_lanes)
        return f"{e}_{lane_index}", lane_index

    # xx meters from the stop end of the edge
    def get_incident_location(self):
        return random.choice(np.arange(10, self.nd.edge_data[self.incident_edge]["length"], 1))

    def add_incident_xml(self):
        # convert string to element
        el_stop = ET.fromstring(self.incident_cmd)
        el_veh = self.incident_veh
        el_veh.set("color", "1,0,0")
        el_veh.append(el_stop)
        self.tree.write(self.route)
        
    # functions for emergency vehicle dispatch

    # def write_emergency_vehicle_xml(self):
    #     xml = self.route
    #     tree = ET.parse(xml)
    #     root = tree.getroot()
    #     emergencyVtypeEle = ET.fromstring(f'<vType id="emergency" accel="0.8" decel="4.5" length="{self.emergency_vehicle_length}" maxSpeed="30" color="0,1,0"/>')
    #     root.insert(0,emergencyVtypeEle)
    #     tree.write(self.route)

    # def read_emergency_vehicle_xml(self):
    #     xml = self.route
    #     tree = ET.parse(xml)
    #     root = tree.getroot()
    #     e = root.findall("vType")[0]
    #     print(e)

    def get_emergency_vehicle_origin(self):
        return random.choice(self.origins)
    
    def get_emergency_vehicle_destination(self):
        return self.incident_edge

    def get_emergency_vehicle_stop_duration(self):
        return self.incident_duration

    def get_emergency_vehicle_route(self):
        stage = traci.simulation.findRoute(self.get_emergency_vehicle_origin(), self.get_emergency_vehicle_destination())
        return stage.edges

    def get_emergency_vehicle_stop_lane(self):
        n_lanes = self.nd.edge_data[self.incident_edge]["nlanes"]
        lane_available = list(range(0, n_lanes))
        print(f"the lane_avaliable list = {lane_available} and the incident_lane = {self.incident_lane_index}")
        lane_available.remove(self.incident_lane_index)
        lane = -9
        while abs(lane - self.incident_lane_index) != 1:
            lane = random.choice(lane_available)
        print(f"lane = {lane}")
        return lane

    def dispath_emergency_vehicle(self):

        print("call dispatch emergency vehicle()")
        # self.read_emergency_vehicle_xml()
        routeID = "emergencyTrip"
        new_vid = "99999999"
        route = self.get_emergency_vehicle_route()
        print(f"the emergency vehicle route is {route}")
        traci.route.add(routeID, route)

        traci.vehicle.add(new_vid, routeID)
        traci.vehicle.setLength(new_vid, self.emergency_vehicle_length)
        traci.vehicle.setColor(new_vid, (0,0,255))
        lane = self.get_emergency_vehicle_stop_lane()
        # print(f"new_vid = {new_vid}, incident_edge = {type(self.incident_edge)}:{self.incident_edge}, incident_location = {type(self.incident_location)}:{self.incident_location}, lane = {type(lane)}:{lane},incident_duration = {type(self.incident_duration)}:{self.incident_duration}")
        traci.vehicle.setStop(new_vid, 
                                self.incident_edge, 
                                self.incident_location,
                                lane,
                                self.incident_duration)

    # def is_incident_car_stopped(self):
    #     """
    #         Once the incident car stops for more than 5 minutes
    #     """        
    #     stopPos = None
    #     stopTime = 0
    #     stopDict = {}
    #     vid = self.get_incident_veh_id()
    #     while traci.simulation.getMinExpectedNumber() > 0:
    #         if vid in traci.vehicle.getIDList():
    #             pos = traci.vehicle.getPosition(vid)
    #             if stopPos is None:
    #                 stopPos = pos
    #             elif stopPos and stopPos == pos:
    #                 stopTime += 1
    #                 stopDict[stopPos] = stopTime
    #                 if stopTime >= 300 and not self.hasEmergencyDispatched:
    #                     print("emergency car is needed")
    #                     self.dispath_emergency_vehicle()
    #                     self.hasIncident += 1
    #                     self.hasEmergencyDispatched = True
    #             else:
    #                 stopTime = 0
    #                 stopPos = pos





# def run(incidentObj):
#     step = 0
#     while traci.simulation.getMinExpectedNumber() > 0:
#         traci.simulationStep()
        
#         stopPos = None
#         stopTime = 0
#         stopDict = {}
#         vid = self.get_incident_veh_id()
#         while traci.simulation.getMinExpectedNumber() > 0:
#             if vid in traci.vehicle.getIDList():
#                 pos = traci.vehicle.getPosition(vid)
#                 if stopPos is None:
#                     stopPos = pos
#                 elif stopPos and stopPos == pos:
#                     stopTime += 1
#                     stopDict[stopPos] = stopTime
#                     if stopTime >= 300 and not self.hasEmergencyDispatched:
#                         print("emergency car is needed")
#                         self.dispath_emergency_vehicle()
#                         self.hasIncident += 1
#                         self.hasEmergencyDispatched = True
#                 else:
#                     stopTime = 0
#                     stopPos = pos

#         step += 1

#     traci.close()
#     sys.stdout.flush()

if __name__ == "__main__":
    net_file = "networks/grid2/net.net.xml"
    route_file = "networks/grid2/random.rou.xml"
    simulation_steps = 900
    incident = Incident(net_file, route_file, simulation_steps, 1, 4)

    incident.add_incident_xml()

    # start traci for emergency vehicle adding

    sumoBinary = 'sumo-gui'

    cfg = "networks/grid2/my.sumocfg"
    traci.start([sumoBinary, "-c", cfg,
                             "--tripinfo-output", "tripinfo.xml"])
    print(f"start the simulation with incident set up")
    step = 0
    stopPos = None
    stopTime = 0
    stopDict = {}
    vid = incident.get_incident_veh_id()
    while traci.simulation.getMinExpectedNumber() > 0:
        traci.simulationStep()
        if vid in traci.vehicle.getIDList():
            pos = traci.vehicle.getPosition(vid)
            if stopPos is None:
                stopPos = pos
            elif stopPos and stopPos == pos:
                stopTime += 1
                stopDict[stopPos] = stopTime
                if stopTime >= 300 and not incident.hasEmergencyDispatched:
                    print("emergency car is needed")
                    incident.dispath_emergency_vehicle()
                    incident.hasIncident += 1
                    incident.hasEmergencyDispatched = True
            else:
                stopTime = 0
                stopPos = pos
        step += 1

    traci.close()
    print(f"simulation completes")


