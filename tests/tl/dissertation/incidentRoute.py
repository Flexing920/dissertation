''' 
The purpose of this code is to prepare the random demand 
generated by the randomTrips.py provided by SUMO official github.

The input is the random.rou.xml from running the command:
    python randomTrips.py -n net.net.xml -r random.rou.xml 
    --fringe-factor=100000000 --period=0.5 -e 900

The output is the editted random.rou.xml with one incident randomly occurs during the middle 1/3 of the simulation period and an emergency vehicle will be dispatched to deal with this incident. The incident relates to only one vehicle at this moment. 

The incident vehicle will stopped in the middle of the network. To leave the room for vehicle rerouting analysis later, the potential incident edges are the ones on the selected edges that around the center of the junctions.

Once the incident happens, the vehicle will stopped in one lane of that edge and adjacent available lane will be occupied once the service vehicle arrives. 
Author: Tianxin Li
Date: July 23, 2021

'''
import numpy as np
import random
import xml.etree.ElementTree as ET
from src.networkdata import NetworkData



class Incident():
    def __init__(self, net_fp, rou_fp, simulation_steps, n_incident=1):
        self.net = net_fp
        self.rou = rou_fp
        self.steps = simulation_steps
        self.n_incident = n_incident
        # network data object from networkdata
        self.nd = NetworkData(self.net)
        self.rou_origins = self.nd.find_origin_edges()
        self.rou_destinations = self.nd.find_destination_edges()
        self.incident_edges = self.nd.incidentEdges
        self.incident_duration = random.choice(np.arange(900, 2100, 300))
        self.incident_orrur_time = self.occur_time()
        self.tree = ET.parse(self.rou)
        self.incident_veh, self.potential_incident_edges = self.generate_incident_veh()
        self.incident_edge = self.set_incident_edge()

        self.incident_lane = self.set_incident_lane()

        self.incident_location = self.set_incident_location()
        self.incident_cmd = '<stop duration="{}" endPos="{}" lane="{}" parking="false" />'.format(self.incident_duration, self.incident_location, self.incident_lane)
    # set the incident occurance time 
    def occur_time(self):
    
        incident_occur_interval = self.steps/3

        incident_time = np.round(random.choice(np.arange(incident_occur_interval, 2 * incident_occur_interval, 1)), 2)

        return "{:.2f}".format(incident_time)


    # find incident element based on the incident time
    def find_incident_veh(self):
        vehs = self.tree.findall("vehicle")
        for x in vehs:
            if x.attrib["depart"] == self.incident_orrur_time:
                return x
        print(f"No veh element available for this incident time!!! Check again.")

    # get the incident vehicle edges
    def get_veh_edges(self, veh):

        # get the edges from the veh element in string format
        veh_edges = veh.findall('route')[0].attrib["edges"]
        # split string into list
        veh_edges = veh_edges.split()
        return veh_edges

    def get_potential_incident_edges(self, veh_edges):
        l = []
        for e in veh_edges:
            if e in self.incident_edges:
                l.append(e)
        return l

    def generate_incident_veh(self):
        es = []
        veh = None
        while len(es) < 1:
            self.incident_orrur_time = self.occur_time()
            veh = self.find_incident_veh()
            route = self.get_veh_edges(veh)
            p_es = self.get_potential_incident_edges(route)
            es = p_es
        return veh, es

    def get_incident_veh_id(self):
        return self.veh.attrib["id"]

    def get_incident_veh_depart(self):
        return self.veh.attrib["depart"]

    def get_incident_occur_edges(self):
        return self.potential_incident_edges

    def set_incident_edge(self):
        return random.choice(self.potential_incident_edges)

    def set_incident_lane(self):
        e = self.incident_edge
        n_lanes = self.nd.edge_data[e]["nlanes"]
        lane_index = random.randrange(n_lanes)
        return f"{e}_{lane_index}"

    # xx meters from the stop end of the edge
    def set_incident_location(self):
        return random.choice(np.arange(10, self.nd.edge_data[self.incident_edge]["length"], 1))

if __name__ == "__main__":
    net_fp = "networks/grid2/net.net.xml"
    rou_fp = "networks/grid2/random.rou.xml"
    simulation_steps = 900
    incident = Incident(net_fp, rou_fp, simulation_steps)
    print(incident.incident_cmd)